// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package components

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func NotificationsScript() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script>\n\t\t// Push Notifications Manager\n\t\tclass NotificationsManager {\n\t\t\tconstructor(userData, swRegistration) {\n\t\t\t\tthis.userData = userData;\n\t\t\t\tthis.swRegistration = swRegistration;\n\t\t\t\tthis.validationInterval = null;\n\t\t\t\tthis.validationIntervalMs = 5 * 60 * 1000; // Check every 5 minutes\n\t\t\t\tthis.init();\n\t\t\t}\n\n\t\t\tasync init() {\n\t\t\t\tconsole.log('Initializing Notifications Manager...');\n\t\t\t\t\n\t\t\t\t// Check if push notifications are supported\n\t\t\t\tif (!('serviceWorker' in navigator) || !('PushManager' in window)) {\n\t\t\t\t\tconsole.log('Push notifications not supported by browser');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Create notification button regardless of SW registration status\n\t\t\t\tthis.createNotificationButton();\n\t\t\t\t\n\t\t\t\t// Check initial status\n\t\t\t\tawait this.checkPushStatus();\n\t\t\t\t\n\t\t\t\t// Start periodic validation\n\t\t\t\tthis.startPeriodicValidation();\n\t\t\t\t\n\t\t\t\t// Clean up on page unload\n\t\t\t\twindow.addEventListener('beforeunload', () => {\n\t\t\t\t\tthis.stopPeriodicValidation();\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// Pause/resume validation based on page visibility\n\t\t\t\tdocument.addEventListener('visibilitychange', () => {\n\t\t\t\t\tif (document.hidden) {\n\t\t\t\t\t\tthis.stopPeriodicValidation();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Check status immediately when page becomes visible\n\t\t\t\t\t\tthis.checkPushStatus().then(() => {\n\t\t\t\t\t\t\tthis.startPeriodicValidation();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// Monitor permission changes\n\t\t\t\tthis.monitorPermissionChanges();\n\t\t\t}\n\n\t\t\tcreateNotificationButton() {\n\t\t\t\tconst notificationSection = document.getElementById('mobile-notifications-section');\n\t\t\t\tconst notificationButton = document.getElementById('mobile-notifications-button');\n\t\t\t\tconst desktopButton = document.getElementById('desktop-notifications-button');\n\t\t\t\t\n\t\t\t\tif (notificationButton) {\n\t\t\t\t\tnotificationButton.addEventListener('click', () => this.enableNotifications());\n\t\t\t\t}\n\t\t\t\tif (desktopButton) {\n\t\t\t\t\tdesktopButton.addEventListener('click', () => this.enableNotifications());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tasync checkPushStatus() {\n\t\t\t\ttry {\n\t\t\t\t\tconsole.log('Checking push notification status...');\n\t\t\t\t\t\n\t\t\t\t\t// Check permission\n\t\t\t\t\tif (Notification.permission !== 'granted') {\n\t\t\t\t\t\tconsole.log('Permission not granted:', Notification.permission);\n\t\t\t\t\t\tthis.showNotificationButton();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If no service worker registration, show button\n\t\t\t\t\tif (!this.swRegistration) {\n\t\t\t\t\t\tconsole.log('No service worker registration available');\n\t\t\t\t\t\tthis.showNotificationButton();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check browser subscription\n\t\t\t\t\tconst subscription = await this.swRegistration.pushManager.getSubscription();\n\t\t\t\t\tif (!subscription) {\n\t\t\t\t\t\tconsole.log('No browser subscription found');\n\t\t\t\t\t\tthis.showNotificationButton();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check server status\n\t\t\t\t\tconst encodedEndpoint = encodeURIComponent(subscription.endpoint);\n\t\t\t\t\tconst response = await fetch(`/api/webpush/status?endpoint=${encodedEndpoint}`);\n\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\tconst data = await response.json();\n\t\t\t\t\t\tif (data.subscribed) {\n\t\t\t\t\t\t\tconsole.log('Server confirms subscription active');\n\t\t\t\t\t\t\tthis.hideNotificationButton();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.log('Server missing subscription, re-subscribing...');\n\t\t\t\t\t\t\tawait this.sendSubscriptionToServer(subscription);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (response.status === 410) {\n\t\t\t\t\t\tconsole.log('Subscription invalid (410), removing and showing button...');\n\t\t\t\t\t\tawait this.handleInvalidSubscription(subscription);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log('Failed to check server status');\n\t\t\t\t\t\tthis.showNotificationButton();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error checking push status:', error);\n\t\t\t\t\tthis.showNotificationButton();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tasync enableNotifications() {\n\t\t\t\ttry {\n\t\t\t\t\t// Request permission\n\t\t\t\t\tif (Notification.permission === 'denied') {\n\t\t\t\t\t\tthis.showToast('Notifications are blocked. Please enable them in browser settings.', 'error');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst permission = await Notification.requestPermission();\n\t\t\t\t\tif (permission !== 'granted') {\n\t\t\t\t\t\tthis.showToast('Notification permission denied', 'error');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ensure we have a service worker registration\n\t\t\t\t\tif (!this.swRegistration) {\n\t\t\t\t\t\tconsole.log('No SW registration, trying to register or get existing one...');\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Try to register a new one\n\t\t\t\t\t\t\tthis.swRegistration = await navigator.serviceWorker.register('/static/sw.js');\n\t\t\t\t\t\t\tconsole.log('Registered new SW for notifications:', this.swRegistration);\n\t\t\t\t\t\t} catch (regError) {\n\t\t\t\t\t\t\t// Try to get existing one\n\t\t\t\t\t\t\tthis.swRegistration = await navigator.serviceWorker.getRegistration();\n\t\t\t\t\t\t\tconsole.log('Got existing SW for notifications:', this.swRegistration);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!this.swRegistration) {\n\t\t\t\t\t\t\tthis.showToast('Service worker not available', 'error');\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if already subscribed\n\t\t\t\t\tconst existingSubscription = await this.swRegistration.pushManager.getSubscription();\n\t\t\t\t\tif (existingSubscription) {\n\t\t\t\t\t\tconsole.log('Already subscribed, sending to server...');\n\t\t\t\t\t\tawait this.sendSubscriptionToServer(existingSubscription);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create new subscription\n\t\t\t\t\tawait this.createPushSubscription();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error enabling notifications:', error);\n\t\t\t\t\tthis.showToast('Failed to enable notifications: ' + error.message, 'error');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tasync createPushSubscription() {\n\t\t\t\ttry {\n\t\t\t\t\t// Get VAPID key\n\t\t\t\t\tconst response = await fetch('/api/webpush/vapid-key');\n\t\t\t\t\tif (!response.ok) {\n\t\t\t\t\t\tthrow new Error('Failed to get VAPID key');\n\t\t\t\t\t}\n\t\t\t\t\tconst data = await response.json();\n\n\t\t\t\t\t// Subscribe to push notifications\n\t\t\t\t\tconst subscription = await this.swRegistration.pushManager.subscribe({\n\t\t\t\t\t\tuserVisibleOnly: true,\n\t\t\t\t\t\tapplicationServerKey: this.urlBase64ToUint8Array(data.publicKey)\n\t\t\t\t\t});\n\n\t\t\t\t\t// Send to server\n\t\t\t\t\tawait this.sendSubscriptionToServer(subscription);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error creating push subscription:', error);\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tasync sendSubscriptionToServer(subscription) {\n\t\t\t\ttry {\n\t\t\t\t\tconst subscriptionData = {\n\t\t\t\t\t\tsubscription: {\n\t\t\t\t\t\t\tendpoint: subscription.endpoint,\n\t\t\t\t\t\t\tkeys: {\n\t\t\t\t\t\t\t\tp256dh: btoa(String.fromCharCode(...new Uint8Array(subscription.getKey('p256dh')))),\n\t\t\t\t\t\t\t\tauth: btoa(String.fromCharCode(...new Uint8Array(subscription.getKey('auth'))))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tusername: this.userData?.username\n\t\t\t\t\t};\n\n\t\t\t\t\tconst response = await fetch('/api/webpush/subscribe', {\n\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\t\tbody: JSON.stringify(subscriptionData)\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\tconsole.log('Successfully subscribed to push notifications');\n\t\t\t\t\t\tthis.hideNotificationButton();\n\t\t\t\t\t\t// Restart periodic validation since we have a new subscription\n\t\t\t\t\t\tthis.startPeriodicValidation();\n\t\t\t\t\t} else if (response.status === 410) {\n\t\t\t\t\t\tconsole.log('Subscription invalid (410), handling...');\n\t\t\t\t\t\tawait this.handleInvalidSubscription(subscription);\n\t\t\t\t\t\tthrow new Error('Subscription is no longer valid');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(`Failed to register subscription on server (status: ${response.status})`);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error sending subscription to server:', error);\n\t\t\t\t\tthis.showToast('Failed to register subscription on server', 'error');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmonitorPermissionChanges() {\n\t\t\t\t// Use modern Permission API if available\n\t\t\t\tif (navigator.permissions) {\n\t\t\t\t\tnavigator.permissions.query({ name: 'notifications' })\n\t\t\t\t\t\t.then(permission => {\n\t\t\t\t\t\t\tpermission.addEventListener('change', () => {\n\t\t\t\t\t\t\t\tconsole.log('Permission changed to:', permission.state);\n\t\t\t\t\t\t\t\tif (permission.state === 'granted') {\n\t\t\t\t\t\t\t\t\t// Auto-subscribe when permission is granted\n\t\t\t\t\t\t\t\t\tthis.createPushSubscription().catch(console.error);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.checkPushStatus();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(() => {\n\t\t\t\t\t\t\tconsole.log('Permission API not supported, using fallback');\n\t\t\t\t\t\t\tthis.setupFallbackMonitoring();\n\t\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis.setupFallbackMonitoring();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetupFallbackMonitoring() {\n\t\t\t\tlet lastPermission = Notification.permission;\n\t\t\t\t\n\t\t\t\tconst checkPermissionChange = () => {\n\t\t\t\t\tconst currentPermission = Notification.permission;\n\t\t\t\t\tif (currentPermission !== lastPermission) {\n\t\t\t\t\t\tconsole.log('Permission changed from', lastPermission, 'to', currentPermission);\n\t\t\t\t\t\tlastPermission = currentPermission;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (currentPermission === 'granted') {\n\t\t\t\t\t\t\tthis.createPushSubscription().catch(console.error);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.checkPushStatus();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Check on focus and visibility change\n\t\t\t\twindow.addEventListener('focus', checkPermissionChange);\n\t\t\t\tdocument.addEventListener('visibilitychange', () => {\n\t\t\t\t\tif (!document.hidden) checkPermissionChange();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tstartPeriodicValidation() {\n\t\t\t\t// Clear any existing interval\n\t\t\t\tthis.stopPeriodicValidation();\n\t\t\t\t\n\t\t\t\t// Only start if notifications are supported and we might have a subscription\n\t\t\t\tif (!('serviceWorker' in navigator) || !('PushManager' in window)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconsole.log('Starting periodic subscription validation...');\n\t\t\t\tthis.validationInterval = setInterval(async () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.validateSubscription();\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error('Error during periodic validation:', error);\n\t\t\t\t\t}\n\t\t\t\t}, this.validationIntervalMs);\n\t\t\t}\n\n\t\t\tstopPeriodicValidation() {\n\t\t\t\tif (this.validationInterval) {\n\t\t\t\t\tconsole.log('Stopping periodic subscription validation');\n\t\t\t\t\tclearInterval(this.validationInterval);\n\t\t\t\t\tthis.validationInterval = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tasync validateSubscription() {\n\t\t\t\ttry {\n\t\t\t\t\t// Check if we still have permission\n\t\t\t\t\tif (Notification.permission !== 'granted') {\n\t\t\t\t\t\tconsole.log('Notification permission revoked, stopping validation');\n\t\t\t\t\t\tthis.stopPeriodicValidation();\n\t\t\t\t\t\tthis.showNotificationButton();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if we have a service worker registration\n\t\t\t\t\tif (!this.swRegistration) {\n\t\t\t\t\t\tconsole.log('No service worker registration during validation');\n\t\t\t\t\t\tthis.showNotificationButton();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get current browser subscription\n\t\t\t\t\tconst subscription = await this.swRegistration.pushManager.getSubscription();\n\t\t\t\t\tif (!subscription) {\n\t\t\t\t\t\tconsole.log('No browser subscription found during validation');\n\t\t\t\t\t\tthis.showNotificationButton();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check with server\n\t\t\t\t\tconst encodedEndpoint = encodeURIComponent(subscription.endpoint);\n\t\t\t\t\tconst response = await fetch(`/api/webpush/status?endpoint=${encodedEndpoint}`);\n\t\t\t\t\t\n\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\tconst data = await response.json();\n\t\t\t\t\t\tif (!data.subscribed) {\n\t\t\t\t\t\t\tconsole.log('Server reports subscription inactive during validation, re-subscribing...');\n\t\t\t\t\t\t\tawait this.sendSubscriptionToServer(subscription);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.log('Subscription validation successful');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (response.status === 410) {\n\t\t\t\t\t\tconsole.log('Subscription invalid during validation (410), handling...');\n\t\t\t\t\t\tawait this.handleInvalidSubscription(subscription);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('Failed to validate subscription with server, status:', response.status);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error validating subscription:', error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Utility methods\n\t\t\turlBase64ToUint8Array(base64String) {\n\t\t\t\tconst padding = '='.repeat((4 - (base64String.length % 4)) % 4);\n\t\t\t\tconst base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');\n\t\t\t\tconst rawData = window.atob(base64);\n\t\t\t\tconst outputArray = new Uint8Array(rawData.length);\n\t\t\t\tfor (let i = 0; i < rawData.length; ++i) {\n\t\t\t\t\toutputArray[i] = rawData.charCodeAt(i);\n\t\t\t\t}\n\t\t\t\treturn outputArray;\n\t\t\t}\n\n\t\t\tasync handleInvalidSubscription(subscription) {\n\t\t\t\ttry {\n\t\t\t\t\tconsole.log('Handling invalid subscription...');\n\t\t\t\t\t\n\t\t\t\t\t// Stop periodic validation since subscription is invalid\n\t\t\t\t\tthis.stopPeriodicValidation();\n\t\t\t\t\t\n\t\t\t\t\t// Unsubscribe from the browser's push manager\n\t\t\t\t\tif (subscription) {\n\t\t\t\t\t\tawait subscription.unsubscribe();\n\t\t\t\t\t\tconsole.log('Unsubscribed from browser push manager');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Notify server to remove the subscription (if endpoint is available)\n\t\t\t\t\tif (subscription && subscription.endpoint) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait fetch('/api/webpush/unsubscribe', {\n\t\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t\t\t\t\t\t\tbody: JSON.stringify({ endpoint: subscription.endpoint })\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tconsole.log('Notified server to remove invalid subscription');\n\t\t\t\t\t\t} catch (serverError) {\n\t\t\t\t\t\t\tconsole.warn('Failed to notify server about invalid subscription:', serverError);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Show notification button for re-subscription\n\t\t\t\t\tthis.showNotificationButton();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error handling invalid subscription:', error);\n\t\t\t\t\tthis.showNotificationButton();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tshowNotificationButton() {\n\t\t\t\tconst mobileSection = document.getElementById('mobile-notifications-section');\n\t\t\t\tconst desktopButton = document.getElementById('desktop-notifications-button');\n\t\t\t\t\n\t\t\t\tif (mobileSection) {\n\t\t\t\t\tmobileSection.classList.remove('hidden');\n\t\t\t\t}\n\t\t\t\tif (desktopButton) {\n\t\t\t\t\tdesktopButton.classList.remove('hidden');\n\t\t\t\t\tdesktopButton.classList.add('flex');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thideNotificationButton() {\n\t\t\t\tconst mobileSection = document.getElementById('mobile-notifications-section');\n\t\t\t\tconst desktopButton = document.getElementById('desktop-notifications-button');\n\t\t\t\t\n\t\t\t\tif (mobileSection) {\n\t\t\t\t\tmobileSection.classList.add('hidden');\n\t\t\t\t}\n\t\t\t\tif (desktopButton) {\n\t\t\t\t\tdesktopButton.classList.add('hidden');\n\t\t\t\t\tdesktopButton.classList.remove('flex');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tshowToast(message, type = 'info') {\n\t\t\t\tconst toast = document.createElement('div');\n\t\t\t\ttoast.className = `fixed top-4 right-4 px-4 py-2 rounded-lg shadow-lg z-50 text-white max-w-sm ${\n\t\t\t\t\ttype === 'success' ? 'bg-green-600' : \n\t\t\t\t\ttype === 'error' ? 'bg-red-600' : 'bg-blue-600'\n\t\t\t\t}`;\n\t\t\t\ttoast.textContent = message;\n\t\t\t\t\n\t\t\t\tdocument.body.appendChild(toast);\n\t\t\t\t\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\ttoast.remove();\n\t\t\t\t}, 5000);\n\t\t\t}\n\t\t}\n\n\t\t// Export for use by PWAManager\n\t\twindow.NotificationsManager = NotificationsManager;\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
